/*
   This file was generated automatically by Alchitry Labs version 1.2.1.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module input_fsm_4 (
    input clk,
    input rst,
    input oneInput,
    input zeroInput,
    input nextValue,
    input previousValue,
    input enterNext,
    output reg [14:0] segValue,
    output reg [5:0] alufn_signal,
    output reg [15:0] out
  );
  
  
  
  wire [16-1:0] M_alu_out;
  wire [3-1:0] M_alu_zvn;
  reg [16-1:0] M_alu_a;
  reg [16-1:0] M_alu_b;
  reg [6-1:0] M_alu_alufn_signal;
  alu_9 alu (
    .a(M_alu_a),
    .b(M_alu_b),
    .alufn_signal(M_alu_alufn_signal),
    .out(M_alu_out),
    .zvn(M_alu_zvn)
  );
  
  wire [1-1:0] M_aluChecker_out;
  reg [6-1:0] M_aluChecker_alufn_signal;
  errorChecker_10 aluChecker (
    .alufn_signal(M_aluChecker_alufn_signal),
    .out(M_aluChecker_out)
  );
  
  localparam A_testInput = 2'd0;
  localparam B_testInput = 2'd1;
  localparam ALUFN_testInput = 2'd2;
  localparam OUT_testInput = 2'd3;
  
  reg [1:0] M_testInput_d, M_testInput_q = A_testInput;
  reg [15:0] M_register_a_d, M_register_a_q = 1'h0;
  reg [3:0] M_counter_a_d, M_counter_a_q = 1'h0;
  reg [15:0] M_register_b_d, M_register_b_q = 1'h0;
  reg [3:0] M_counter_b_d, M_counter_b_q = 1'h0;
  reg [5:0] M_register_singal_d, M_register_singal_q = 6'h3f;
  reg [2:0] M_counter_signal_d, M_counter_signal_q = 1'h0;
  
  always @* begin
    M_testInput_d = M_testInput_q;
    M_counter_b_d = M_counter_b_q;
    M_counter_a_d = M_counter_a_q;
    M_counter_signal_d = M_counter_signal_q;
    M_register_singal_d = M_register_singal_q;
    M_register_b_d = M_register_b_q;
    M_register_a_d = M_register_a_q;
    
    segValue = 15'h0000;
    M_register_a_d = M_register_a_q;
    M_register_b_d = M_register_b_q;
    M_register_singal_d = M_register_singal_q;
    M_counter_a_d = M_counter_a_q;
    M_counter_b_d = M_counter_b_q;
    M_counter_signal_d = M_counter_signal_q;
    M_alu_a = 16'h0000;
    M_alu_b = 16'h0000;
    M_alu_alufn_signal = 6'h00;
    out = M_alu_out;
    M_aluChecker_alufn_signal = M_register_singal_q;
    alufn_signal = M_register_singal_q;
    
    case (M_testInput_q)
      A_testInput: begin
        if (oneInput == 1'h1) begin
          M_register_a_d[(M_counter_a_q)*1+0-:1] = 1'h1;
        end
        if (zeroInput == 1'h1) begin
          M_register_a_d[(M_counter_a_q)*1+0-:1] = 1'h0;
        end
        if (nextValue == 1'h1) begin
          M_counter_a_d = M_counter_a_q + 1'h1;
        end
        if (previousValue == 1'h1) begin
          M_counter_a_d = M_counter_a_q - 1'h1;
        end
        segValue[10+4-:5] = 5'h0a;
        segValue[5+4-:5] = M_counter_a_q;
        segValue[0+4-:5] = M_register_a_q[(M_counter_a_q)*1+0-:1];
        out = M_register_a_q;
        if (enterNext == 1'h1) begin
          M_testInput_d = B_testInput;
        end
      end
      B_testInput: begin
        if (oneInput == 1'h1) begin
          M_register_b_d[(M_counter_b_q)*1+0-:1] = 1'h1;
        end
        if (zeroInput == 1'h1) begin
          M_register_b_d[(M_counter_b_q)*1+0-:1] = 1'h0;
        end
        if (nextValue == 1'h1) begin
          M_counter_b_d = M_counter_b_q + 1'h1;
        end
        if (previousValue == 1'h1) begin
          M_counter_b_d = M_counter_b_q - 1'h1;
        end
        segValue[10+4-:5] = 5'h0b;
        segValue[5+4-:5] = M_counter_b_q;
        segValue[0+4-:5] = M_register_b_q[(M_counter_b_q)*1+0-:1];
        out = M_register_b_q;
        if (enterNext == 1'h1) begin
          M_testInput_d = ALUFN_testInput;
        end
      end
      ALUFN_testInput: begin
        if (oneInput == 1'h1) begin
          M_register_singal_d[(M_counter_signal_q)*1+0-:1] = 1'h1;
        end
        if (zeroInput == 1'h1) begin
          M_register_singal_d[(M_counter_signal_q)*1+0-:1] = 1'h0;
        end
        if (nextValue == 1'h1) begin
          M_counter_signal_d = M_counter_signal_q + 1'h1;
        end
        if (previousValue == 1'h1) begin
          M_counter_signal_d = M_counter_signal_q - 1'h1;
        end
        segValue[10+4-:5] = 5'h05;
        segValue[5+4-:5] = M_counter_signal_q;
        segValue[0+4-:5] = M_register_singal_q[(M_counter_signal_q)*1+0-:1];
        alufn_signal = M_register_singal_q;
        if (enterNext == 1'h1) begin
          M_testInput_d = OUT_testInput;
        end
      end
      OUT_testInput: begin
        M_alu_a = M_register_a_q;
        M_alu_b = M_register_b_q;
        M_alu_alufn_signal = M_register_singal_q;
        out = M_alu_out;
        M_aluChecker_alufn_signal = M_register_singal_q;
        segValue[10+4-:5] = 5'h00;
        segValue[5+4-:5] = 5'h11;
        segValue[0+4-:5] = 5'h12;
        if (M_aluChecker_out == 1'h1) begin
          out = 16'h0000;
          alufn_signal = 6'h3f;
          segValue[10+4-:5] = 5'h0e;
          segValue[5+4-:5] = 5'h10;
          segValue[0+4-:5] = 5'h10;
        end
        if (enterNext == 1'h1) begin
          M_testInput_d = A_testInput;
        end
      end
      default: begin
        M_testInput_d = A_testInput;
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_register_a_q <= 1'h0;
      M_counter_a_q <= 1'h0;
      M_register_b_q <= 1'h0;
      M_counter_b_q <= 1'h0;
      M_register_singal_q <= 6'h3f;
      M_counter_signal_q <= 1'h0;
      M_testInput_q <= 1'h0;
    end else begin
      M_register_a_q <= M_register_a_d;
      M_counter_a_q <= M_counter_a_d;
      M_register_b_q <= M_register_b_d;
      M_counter_b_q <= M_counter_b_d;
      M_register_singal_q <= M_register_singal_d;
      M_counter_signal_q <= M_counter_signal_d;
      M_testInput_q <= M_testInput_d;
    end
  end
  
endmodule
